# RUNBOOK

## Pre-Release Checklist
1. Install deps: `npm install`
2. Type safety: `npm run typecheck`
3. Lint: `npm run lint`
4. Production build: `npm run build`
5. Security scan: `npm audit`

## Required Env / Runtime
- Local development uses `.env.local` as the source of truth for secrets and DB URLs.
- `.env.example` is key-only template and must not contain real values.
- Dev server runs on port `3001` by default.
- Database must be PostgreSQL in staging/production.
- Required env values for runtime:
  - `DATABASE_URL` (Vercel Postgres pooled URL)
  - `DATABASE_URL_UNPOOLED` (direct URL for migrations/long transactions)
  - `AUTH_URL`
  - `AUTH_SECRET`
  - `GOOGLE_CLIENT_ID`
  - `GOOGLE_CLIENT_SECRET`
  - `PAYMENT_PROVIDER` (`MOCK` or `PORTONE`)
  - `NEXT_PUBLIC_PAYMENT_PROVIDER` (`MOCK` or `PORTONE`)
  - `RESEND_API_KEY`
  - `EMAIL_FROM`
  - `PORTONE_STORE_ID`
  - `PORTONE_CHANNEL_KEY`
  - `PORTONE_API_SECRET`
  - `PORTONE_WEBHOOK_SECRET`
  - `NEXT_PUBLIC_SITE_URL`
- For local setup, configure `.env.local`:
  - `AUTH_URL=http://localhost:3001`
  - `AUTH_SECRET=<openssl rand -base64 32>`
  - `GOOGLE_CLIENT_ID=<from Google Cloud>`
  - `GOOGLE_CLIENT_SECRET=<from Google Cloud>`
  - `DATABASE_URL=postgresql://...`
  - `DATABASE_URL_UNPOOLED=postgresql://...`
  - Never use `file:./dev.db` for Prisma datasource.

## Local Run
- Dev: `npm run dev`
- Prod build: `npm run build`
- Prod start: `npm run start`
- Prisma generate: `npm run prisma:generate`
- Prisma migrate (deploy-safe): `npm run prisma:migrate`
- Prisma migrate for local dev: `npm run prisma:migrate:dev`
- Prisma seed: `npm run db:seed`
- DB health check endpoint: `GET /api/health/db` (returns `{ ok: true|false }`)
- Booking/Payment schema updates:
  1. update Prisma schema
  2. create migration in dev via `npm run prisma:migrate:dev`
  3. apply in staging/prod via `npm run prisma:migrate`
  4. run seed if needed via `npm run db:seed`

## PWA (Installable App)
- Manifest route: `/manifest.webmanifest`
- Service worker output: `/sw.js` (generated by `@serwist/next`)
- Offline fallback page: `/offline`

### Local PWA install test
1. Run `npm run build && npm run start`.
2. Open `http://localhost:3000` (or your configured port) in Chrome/Edge on desktop or Android.
3. Open DevTools -> Application:
   - check Manifest is valid
   - check Service Worker is installed and activated
4. Trigger install:
   - desktop: use install icon in address bar
   - Android: "Add to Home screen"
5. Go offline (DevTools -> Network -> Offline) and refresh:
   - app should show `/offline` fallback for navigations.

### Staging/production PWA test (Vercel)
1. Deploy staging build to HTTPS domain.
2. Ensure `/manifest.webmanifest` and `/sw.js` return 200.
3. On Android Chrome:
   - open staging URL
   - wait a few seconds for SW install
   - use browser menu -> Install app
4. Launch from home screen:
   - app opens standalone (no browser chrome).
5. Turn on airplane mode and reopen:
   - fallback/offline behavior is shown instead of network error page.

## Vercel Runtime Constraints
- Vercel Functions filesystem is read-only at runtime except `/tmp` (ephemeral).
- Any DB that writes to local files (for example SQLite `file:./dev.db`) is not durable in Vercel Functions.
- SQLite is therefore unsuitable for production/staging persistence on Vercel.
- Use managed PostgreSQL (Vercel Postgres, Neon, Supabase, RDS, etc.) and connect via `DATABASE_URL`.

## Troubleshooting

### 1) `EADDRINUSE: 3001`
- Find PID: `netstat -ano | findstr :3001`
- Kill PID: `taskkill /PID <PID> /F`
- Restart: `npm run dev`

### 2) Route conflict (`route.ts` + `page.tsx`)
- Keep one owner per URL path.
- Prefer `page.tsx` for UI routes, route handlers only for API/HTTP handler use.

### 3) `useSearchParams` build error
- Wrap client components using `useSearchParams` with `Suspense`.
- If used from layout-level UI, wrap that component too.

### 4) Language resets after navigation
- Verify root layout passes `initialLang` from cookies.
- Verify `LanguageProvider` persists to cookie + localStorage and refreshes router.

### 5) Logout 404
- Ensure links point to `/logout`.
- Keep compatibility redirects for `/auth/logout`, `/auth/signout`, `/signout`.

### 6) Prisma migration fails in Vercel
- Verify `DATABASE_URL` points to PostgreSQL.
- Run `npm run prisma:migrate` (deploy) in CI/CD or before promotion.
- Ensure migration lock provider is `postgresql`.

### 7) Booking confirmed but no email
- Verify `RESEND_API_KEY` and `EMAIL_FROM`.
- Confirm `PAYMENT_PROVIDER=MOCK` for MVP confirm endpoint.
- Check server logs for `[booking-confirm] email send failed`.

### 8) PortOne webhook not confirming booking
- Verify `PAYMENT_PROVIDER=PORTONE` and `NEXT_PUBLIC_PAYMENT_PROVIDER=PORTONE`.
- Verify webhook endpoint URL is reachable: `/api/payments/portone/webhook`.
- Verify webhook uses `Content-Type: application/json`.
- Verify `PORTONE_WEBHOOK_SECRET` matches PortOne Console value.
- Webhook verification uses **raw body text** (`request.text()`), do not JSON-parse before verify.
- Check server logs for `[portone-webhook]` errors.

## PortOne V2 Setup (Webhook-based confirmation)
1. In PortOne Console (V2), configure channel and copy:
   - Store ID -> `PORTONE_STORE_ID`
   - Channel Key -> `PORTONE_CHANNEL_KEY`
2. Issue API Secret and set `PORTONE_API_SECRET`.
3. Register webhook URL:
   - `https://<your-domain>/api/payments/portone/webhook`
   - Content-Type: `application/json`
4. Issue webhook secret and set `PORTONE_WEBHOOK_SECRET`.
5. Set `NEXT_PUBLIC_SITE_URL` (for redirect URL generation), e.g. `https://staging.example.com`.
6. Set provider flags:
   - `PAYMENT_PROVIDER=PORTONE`
   - `NEXT_PUBLIC_PAYMENT_PROVIDER=PORTONE`
7. Restart app and verify checkout flow:
   - checkout -> Pay now -> PortOne window -> redirect `/payment-redirect` -> `/checkout/success/[token]`.
8. In PortOne Console, run webhook "호출 테스트":
   - verify booking status updates to `CONFIRMED`
   - verify confirmation email is sent once
   - verify duplicate webhook calls are ignored (idempotent by webhook-id).

## Google OAuth Setup (Auth.js / NextAuth)
1. Open Google Cloud Console -> APIs & Services -> OAuth consent screen.
2. Create/choose a project and configure OAuth consent.
3. Create OAuth 2.0 Client ID (Web application).
4. Add authorized redirect URI:
   - `http://localhost:3001/api/auth/callback/google`
5. Put `GOOGLE_CLIENT_ID` and `GOOGLE_CLIENT_SECRET` into `.env.local`.
6. Generate `AUTH_SECRET`:
   - Windows PowerShell example: `[Convert]::ToBase64String((1..32 | ForEach-Object {Get-Random -Maximum 256}))`
7. Restart dev server and test:
   - click `Continue with Google` in auth modal
   - verify callback returns to current page
   - verify `/logout` signs out and returns home

## Security / Audit Notes
- `npm audit` currently reports moderate vulnerabilities in transitive dependencies.
- Do **not** run `npm audit fix --force` blindly in release branch (can introduce breaking upgrades).
- Review dependency upgrade path (especially Prisma-related chain) before force updates.
